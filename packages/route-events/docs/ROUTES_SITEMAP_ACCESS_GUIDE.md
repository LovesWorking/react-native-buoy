# Expo Router Sitemap Access Guide

**Audience:** `@react-buoy/route-events` maintainers  
**Scope:** How to read the complete Expo Router route tree (aka sitemap) at runtime in Expo Go + DevBuilds without relying on unsupported hacks.

---

## TL;DR

1. **Import the router store through the shared helper** (`loadRouteNode()`), which already tries both the compiled `build/` path and the legacy `src/` path and logs clear errors when expo-router is missing.
2. **Wait until the router is mounted** (`store.navigationRef.isReady()` or `store.routeNode` truthy).
3. **Read `store.routeNode` once and cache it.** This tree is generated by `getRoutes()` from the app directory structure and already contains every route, layout, group, redirect, etc.
4. **Parse or filter the tree locally** (e.g., with `RouteParser`) and never hit the `/_sitemap` screen or try to reconstruct the tree from navigation state.

---

## Execution Order (Think Like the JS Engine)

1. **Expo Router bootstraps** `ExpoRoot` → `useStore()`; this immediately calls `getRoutes()` and assigns the resulting `RouteNode` tree onto `store.routeNode`.
2. **Devtools code runs later** (after the app JS bundle loads). When we `require("expo-router/build/global-state/router-store")`, we’re getting a singleton whose `routeNode` property is either already populated (normal case) or `undefined` until the store finishes initialization.
3. **As soon as the store is ready**, `store.routeNode` becomes stable for the lifetime of the app (fast refresh will update it). No additional async work is required, so reading it is O(1).
4. **Consumer parses the tree** → `RouteParser.parseRouteTree(store.routeNode)` → UI renders sitemap.
5. **When routes change (Fast Refresh, code push)** `store.routeNode` is replaced; re-run parsing if you need hot updates (e.g., listen to Fast Refresh ping or expose a manual refresh).

---

## Access Patterns

### 1. Safe Import & Type Usage

```ts
import { loadRouteNode } from "../expoRouterStore";
import { RouteParser } from "../RouteParser";

const routeNode = loadRouteNode(); // returns null + warning if expo-router missing
const routes = routeNode ? RouteParser.parseRouteTree(routeNode) : [];
```

- `loadRouteNode()` internally tries both `expo-router/build/global-state/router-store` and the legacy `/src/` path so it works in Expo Go, DevBuilds, and production.
- When expo-router is not installed or not initialized, it logs a single `[RouteEvents] Unable to load expo-router internals...` message (dev builds only) and returns `null` so the UI can stay mounted.
- Type safety still comes from `expo-router/build/Route.d.ts`. Import that file as a type-only dependency when you need to reference `RouteNode` in application code.

### 2. Readiness Guard

```ts
function waitForRouteTree(): RouteNode {
  const routeNode = loadRouteNode();
  if (routeNode) return routeNode;

  throw new Error(
    "Expo Router route tree not ready. Mount the devtool after ExpoRoot or trigger loadRouteNode() inside a retry loop."
  );
}
```

- In practice, our devtools modal mounts after the app, so `routeNode` is almost always present.
- If we ever need to mount earlier, poll (with a short retry loop) instead of blocking the render thread. The helper already logs a warning whenever the navigation ref is ready but `routeNode` still isn’t available.

### 3. Parsing & Filtering

```ts
export function loadSitemap(options?: RouteParserOptions) {
  const routeNode = loadRouteNode();
  if (!routeNode) {
    return { groups: [], routes: [], stats: RouteParser.getRouteStats([]) };
  }

  const routes = RouteParser.parseRouteTree(routeNode);
  const filtered = RouteParser.filterRoutes(routes, options?.searchQuery ?? "");
  return RouteParser.organizeRoutes(filtered);
}
```

- `RouteParser` already knows how to ignore layouts, handle groups, classify dynamic segments, etc. Feed it the real tree rather than fabricating data.
- Filter out `node.internal` or `node.generated` routes before displaying them (same as Expo’s built-in `/_sitemap` view).
- The helper logs (DEV-only) when the tree isn’t ready so developers immediately know expo-router is missing/misconfigured.

### 4. Refresh Strategy

- `routeNode` only changes when the bundle reloads. For devtools we can expose a manual “Refresh Routes” button that just re-reads and re-parses the tree.
- No need to subscribe to navigation events; the sitemap is static metadata, not runtime state.

---

## Do’s & Don’ts

| ✅ Do | ❌ Don’t |
|------|---------|
| Import from `expo-router/build/...` | Import from `expo-router/src/...` in production bundles |
| Cache `routeNode` per session | Recompute the tree from `useNavigationState()` (only shows active branch) |
| Use `RouteParser` + `RouteInfo` types | Call `JSON.stringify(store.routeNode)` in render paths (huge objects) |
| Filter `internal`/`generated` nodes before UI | Navigate to `/_sitemap` just to read text (slow + user-visible) |
| Guard for `store.routeNode` being undefined | Assume it exists during unit tests (mock it) |

---

## Compatibility Notes

| Expo Router Version | Status | Notes |
|---------------------|--------|-------|
| ≥ 2.0 (SDK 49+) | ✅ Supported | `expo-router/build/global-state/router-store` + `RouteNode` exist |
| 1.x (SDK 48) | ⚠️ Limited | Store shape the same but build path may differ; fall back to `/src/` |
| Future versions | ✅ Plan | `routeNode` is used by Expo’s own `/_sitemap` (see `build/views/Sitemap.js`), so regressions would break Expo too. Still, wrap `require` in `try/catch` and surface actionable errors. |

**Testing:** verify in both Expo Go and DevBuild. The route tree is generated purely from the Metro context, so it matches across runtimes. When testing production builds, confirm the require path resolves (use an E2E smoke test that calls `loadRouteNode()`).

---

## Reference APIs & Types

```ts
type RouteNode = {
  type: "route" | "layout" | "group" | "api" | "redirect" | "rewrite";
  route: string;              // Segment name ("index", "[id]", "(tabs)")
  children: RouteNode[];
  dynamic: null | Array<{ name: string; deep: boolean; notFound?: boolean }>;
  contextKey: string;         // Metro module path (./app/posts/[id].tsx)
  internal?: boolean;         // Hide Expo internals like /_sitemap
  generated?: boolean;        // Virtual nodes (auto layouts)
  initialRouteName?: string;  // Preferred child (tabs)
};
```

Use these helpers from our codebase:
- `RouteParser.parseRouteTree(routeNode)` → `RouteInfo[]`
- `RouteParser.filterRoutes(routes, query)`
- `RouteParser.organizeRoutes(routes)`
- `RouteParser.getRouteStats(routes)`

---

## Validation Checklist

1. `require("expo-router/build/global-state/router-store")` succeeds in Expo Go, DevBuild, and production bundle.
2. `store.routeNode` contains children (log once behind a development flag).
3. `RouteParser.parseRouteTree(routeNode)` returns >0 routes from the example app.
4. Ignoring `node.internal` removes `/_sitemap`, `/api`, `/__dev`.
5. Manual “Refresh Routes” re-parses without a reload.

If any step fails, ask the user to capture `expo-router` version and confirm the build path; fall back to the `/src/` require path temporarily while flagging an issue.

---

## Related References

- `packages/route-events/docs/ROUTING_RESEARCH_FINDINGS.md` – High-level routing architecture.
- `packages/route-events/docs/ROUTENODE_TYPE_DEFINITION.md` – Full `RouteNode` type.
- Expo Router source: `expo-router/build/views/Sitemap.js` shows Expo’s own implementation; our solution should mirror it.
