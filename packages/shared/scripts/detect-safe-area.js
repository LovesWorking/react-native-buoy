#!/usr/bin/env node
/**
 * Safe Area Detection Script
 *
 * This postinstall script detects if react-native-safe-area-context is installed
 * and generates the appropriate implementation file.
 *
 * This approach provides TRUE zero-config because:
 * 1. No metro.config.js changes needed
 * 2. Detection happens at install time (not bundle time)
 * 3. Metro sees static imports only
 * 4. Works with any Metro version
 *
 * Key insight: When the package IS installed, we use SafeAreaInsetsContext
 * directly with useContext() instead of useSafeAreaInsets(). This allows us
 * to detect when SafeAreaProvider is missing (returns null) without throwing
 * an error, enabling graceful fallback to pure JS implementation.
 */

const fs = require("fs");
const path = require("path");

const OUTPUT_FILE = path.join(__dirname, "..", "src", "hooks", "safe-area-impl.ts");

function moduleExists(name) {
  try {
    require.resolve(name);
    return true;
  } catch (e) {
    return false;
  }
}

let content;
let detectedModule;

if (moduleExists("react-native-safe-area-context")) {
  detectedModule = "react-native-safe-area-context";
  content = `/**
 * Auto-generated safe area implementation
 * Detected: react-native-safe-area-context
 * Generated at: ${new Date().toISOString()}
 *
 * DO NOT EDIT - This file is generated by scripts/detect-safe-area.js
 *
 * This implementation uses SafeAreaInsetsContext directly with useContext()
 * instead of the useSafeAreaInsets() hook. This allows graceful fallback
 * when SafeAreaProvider is not present (useContext returns null instead of throwing).
 */

import { useContext } from "react";
import { SafeAreaInsetsContext } from "react-native-safe-area-context";

export interface NativeSafeAreaInsets {
  top: number;
  bottom: number;
  left: number;
  right: number;
}

export const safeAreaType: "native" | "pure-js" = "native";

export const hasSafeAreaPackage = true;

/**
 * Hook that attempts to get native safe area insets.
 * Returns null if SafeAreaProvider is not present (no error thrown).
 *
 * Unlike useSafeAreaInsets() from react-native-safe-area-context which throws
 * when no provider is found, this uses useContext directly which returns null.
 */
export const useNativeSafeAreaInsets = (): NativeSafeAreaInsets | null => {
  // useContext returns null when no provider is present - no error!
  const insets = useContext(SafeAreaInsetsContext);
  return insets;
};
`;
} else {
  detectedModule = null;
  content = `/**
 * Auto-generated safe area implementation
 * Detected: none
 * Generated at: ${new Date().toISOString()}
 *
 * DO NOT EDIT - This file is generated by scripts/detect-safe-area.js
 *
 * No react-native-safe-area-context found. Using pure JS fallback only.
 * Install react-native-safe-area-context for more accurate safe area values.
 */

export interface NativeSafeAreaInsets {
  top: number;
  bottom: number;
  left: number;
  right: number;
}

export const safeAreaType: "native" | "pure-js" = "pure-js";

export const hasSafeAreaPackage = false;

/**
 * Hook that returns null since react-native-safe-area-context is not installed.
 * The main useSafeAreaInsets hook will use pure JS fallback.
 */
export const useNativeSafeAreaInsets = (): NativeSafeAreaInsets | null => {
  return null;
};
`;
}

// Ensure directory exists
const dir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(dir)) {
  fs.mkdirSync(dir, { recursive: true });
}

fs.writeFileSync(OUTPUT_FILE, content);

console.log(
  `[@react-buoy/shared-ui] Safe area implementation configured: ${detectedModule || "pure-js fallback"}`
);
