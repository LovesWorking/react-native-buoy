# RN Better Dev Tools – Senior Review

## Critical Fixes
- **Persisted position never saves after a drag** – `packages/package-1/src/floatingMenu/floatingTools.tsx:484` wires `enabled: enablePositionPersistence && !isDragging` into `useFloatingToolsPosition`. When a drag starts we set `isDragging` to true, recompute `savePosition` with `enabled=false`, and the `handleDragEnd` closure (`floatingTools.tsx:595-618`) then calls that disabled saver. Because React only rebinds the callback _after_ the handler finishes, every `savePosition` call during and after the drag is a no-op, so the bubble jumps back to the last persisted value after a reload. We should split the concerns: keep persistence listeners disabled while dragging, but always allow explicit `savePosition` calls (or move the drag lifecycle into the hook so we never close over a stale disabled saver). This is the biggest functional regression compared to the previous menu.

## High-Priority Improvements
- **AsyncStorage fallback duplicates infrastructure and breaks bundling** – `floatingTools.tsx:110-141` eagerly `require`s `@react-native-async-storage/async-storage`. Metro treats that as a hard dependency, so a consuming app without AsyncStorage installed fails to bundle even though we wanted a soft fallback. We already ship the `safeAsyncStorage` helpers in `@monorepo/shared` (`packages/shared/src/utils/safeAsyncStorage.ts`). Reuse that abstraction instead of reinventing it so we get tree shaking, consistent logging, and dynamic `import()` that Metro can drop when the module isn’t present.
- **Settings modal drops new tools** – `DevToolsSettingsModal.tsx:127-146` merges storage with `basicDefaultSettings`, ignoring the `generateDefaultSettings(availableApps)` result. Any app id that isn’t hard-coded in `basicDefaultSettings` silently disappears from the toggle UI until the user clears storage. This blocks us from shipping new tools as a workspace plugin. Fix by merging in the current `defaultSettings` map before applying stored overrides, and mirror that change inside `useDevToolsSettings` (`DevToolsSettingsModal.tsx:473-526`).
- **Can’t hide by dragging** – `DraggableHeader.tsx:73-77` clamps X to `containerBounds.width - elementSize.width`. We then test `bubbleMidpoint > screenWidth` in `floatingTools.tsx:599-608` to decide if we should auto-hide, but that condition is now unreachable. Either relax the clamp (allow dragging past the right edge while we manage bounds ourselves) or compute the hide threshold against the unclamped gesture delta so the “drag to dock” affordance actually works.
- **Static viewport assumptions** – `useFloatingToolsPosition` caches `Dimensions.get('window')` (`floatingTools.tsx:233-272`) and we never listen for rotation or split-screen changes. After a rotation the persisted coordinates can end up outside the screen and the bubble disappears. The dial (`dial/DialDevTools.tsx:26-28`) has the same issue and will render off-screen on tablets in landscape. We should subscribe to `Dimensions` changes (or `useWindowDimensions`) and re-run validation to clamp saved coordinates into the new bounds.
- **Modal lifecycle vs. AppHost flow** – When an installed app supplies `component` + `launchMode: 'self-modal'`, we close the dial (`FloatingMenu.tsx:75-101` and `DialDevTools.tsx:142-168`) and expect the component to manage its own visibility, but we never propagate `onClose` to reopen the floating bubble. For singleton apps this feels okay, but for multi-instance tools the floating row stays hidden until persistence resets. Consider wiring `AppHost` callbacks into `FloatingMenu` so closing the hosted modal unhides the bubble automatically.

## Medium / Polish
- **File needs to be decomposed** – `floatingTools.tsx` is 713 lines mixing storage, animation, UI, and accessibility logic. This makes future tooling (e.g. registering another bubble variant) harder. Suggest extracting the persistence hook into its own module (and reusing the shared storage helper), pulling out small presentational atoms (`GripVerticalIcon`, `Divider`, etc.), and moving style constants into a `styles.ts` so we can codegen variants for dark/light themes.
- **Stale comparisons to native-driver** – We advertise “@performance Uses native driver” in the JSDoc (`floatingTools.tsx:462-464`), but every animation sets `useNativeDriver: false`. That’s fine given we animate layout, but we should rewrite the doc (or convert to Reanimated/shared value) to avoid misleading consumers.
- **Unnecessary state & refs** – `DraggableHeader.tsx:31-33` keeps `touchOffsetRef` that is no longer referenced and `floatingTools.tsx:472` declares `saveTimeoutRef` but never assigns to it. Removing dead refs simplifies reasoning and eliminates the impression of missing behavior.
- **Value extraction is brittle** – `DraggableHeader.tsx:64-77` reads positions via `Number(JSON.stringify(position.x))`. This relies on RN’s `toJSON` implementation and breaks under the JSI-only runtime. Prefer `position.x.__getValue()` (with a guard) or migrate to `useAnimatedRef` so we pull layout from the drag handler instead of poking internal Animated state.
- **Dial animations leaked** – `DialDevTools.tsx:238-320` launches multiple `Animated.loop` instances but only stores `glitchIntervalRef` / `pulseAnimationRef`. The loops for `floatingAnim` and `breathingScale` keep running even after the component unmounts, which costs battery time in dev builds. Capture the `Animated.loop` return value and stop it inside the cleanup.
- **Unused animated values** – `DialDevTools.tsx:102` defines `circuitOpacity` but never applies it to a view, so we pay to drive an animation that has no visible effect. Either wire it into the SVG background or drop it.
- **Settings UX** – The modal nests a `TouchableOpacity` inside another `TouchableOpacity` (`DevToolsSettingsModal.tsx:230-370`). This double pressable pattern is hard for screen readers; better to make the outer container non-pressable and rely on the pill control or vice versa. While we’re there, we should set `accessibilityRole="switch"` and announce the enabled count instead of silently refusing the seventh toggle.
- **Plug-in metadata defaults** – `generateDefaultSettings` (`DevToolsSettingsModal.tsx:50-103`) hard codes knowledge of the built-in tool ids. Move those defaults into the app registration (e.g. `InstalledApp` could expose `defaultSlotStates`) so new packages can ship their own preferred defaults without touching core.
- **Singleton handling** – `AppHost.tsx:19-56` silently drops duplicate `open()` calls for singleton tools, but callers get no feedback. Return the existing `instanceId` so call sites can focus the already-open app (or add an `ensureVisible` helper).

## Extensibility & Tooling Ideas
1. **App registry contract** – Extend `InstalledApp` (`floatingMenu/types.ts:10-43`) with optional metadata (`defaultDialEnabled`, `defaultRowEnabled`, `category`, `keywords`). Keep a central registry map so the settings modal and the dial stay in sync without duplicating `knownDefaults` logic.
2. **Declarative layouts** – `FloatingMenu.tsx:52-118` bakes the row layout. Consider making the floating bubble render a list of `FloatingToolItem` descriptors (label, icon, action) supplied by each app. That opens the door for context-specific toolbars and per-app overrides (e.g. hiding the environment indicator in production builds).
3. **Dev-tool theming** – The dial and settings modal share the cyberpunk theme. Move those colors into `@monorepo/shared` (e.g. `devToolsTheme`) so we can skin them for different client apps without forking.
4. **Instrumentation hooks** – Expose callbacks on `FloatingMenu` for analytics (`onToolOpened`, `onToolClosed`, `onPositionSaved`). Future tools like network inspectors will want to log their usage to correlate with server logs.
5. **Test harness** – Add a Jest test (or Detox story) validating that enabling/disabling tools updates both the dial and floating row. Today the logic is only covered manually.
6. **Documentation** – Document the plug-and-play API (`InstalledApp.component`, `launchMode`, `singleton`) in `docs/` so downstream devs know they no longer have to manage modals themselves.

## Suggested Validation
- After fixing persistence, verify dragging the bubble, force-quit the app, and ensure it restores to the new coordinates.
- Drop a fake `@monorepo/tool-foo` into `apps` and confirm it appears in the settings modal with sensible defaults.
- Rotate an iPad simulator and ensure both the dial and bubble stay visible and clamped inside the viewport.


## Additional Observations
- **State bus coupling** – `settingsBus` (`floatingMenu/settingsBus.ts:4-21`) is a static singleton, which means multiple floating bubbles in the same app (different navigation stacks) will mutate each other’s settings. If we ever ship the dev tools as a library to be embedded twice (e.g. host app + plugin sandbox), we should scope the bus to a React context or allow consumers to pass an event emitter instance.
- **Promise-returning `onPress` contract** – `FloatingMenu.tsx:67-98` hides the row while awaiting a promise from legacy `onPress` handlers, but any rejection leaves us in the hidden state (the catch block just swallows errors). We should re-show the bubble on rejection so a broken tool doesn’t strand the UI.
- **Dial placeholder handling** – Disabled dial slots create empty markers via `DialDevTools.tsx:130-139`, yet we still include them in `totalIcons`. For layouts with many disabled items the dial feels sparse. Consider filtering to enabled icons for layout and rendering a subtle badge (e.g. “3 hidden”) instead of empty spokes.
- **Accessibility gaps** – The center dial button (`DialDevTools.tsx:457-489`) is purely visual. Add `accessibilityRole="button"`, `accessibilityLabel`, and ensure the modal trap focuses the first toggle when opened. Likewise the floating grip handle should expose `accessibilityHint="Double tap to collapse"` so VoiceOver users understand the behavior.
- **Environment indicator ties to settings** – If `floatingTools.environment` is false we suppress the badge entirely (`FloatingMenu.tsx:54-70`). Consider leaving a minimal indicator (e.g. a single colored dot) so engineers still know which backend they’re hitting even when they collapse the row.
- **Animation performance on low-end devices** – The dial currently orchestrates five overlapping animation loops (breathing, floating, pulse, rotation, glitch). On entry-level Android hardware this causes noticeable dropped frames. Provide a `performanceMode` flag (e.g. `reducedMotion`) to disable non-essential loops when requested.
- **Event naming** – `FloatingMenuActions` and `FloatingMenuState` are wide-open `Record<string, unknown>` (`floatingMenu/types.ts:8-18`). As we build more tooling it would help to standardize action names or at least namespace them (`devtools.query.refetch`, `devtools.logs.clear`) so different teams don’t accidentally collide.
- **Host modal styling** – `AppOverlay` renders host-modal content in a white card (`AppHost.tsx:71-103`), but there’s no safe-area padding or keyboard avoidance. Provide props to configure the frame or reuse the `JsModal` chrome so all dev apps share a consistent look.
- **Example app coverage** – `example/App.tsx:19-68` registers a single env modal. Add a second example tool (e.g. React Query viewer) to prove both the dial and floating row handle multiple entries and to dogfood the plug-and-play path.

## Alternative Design Ideas
- **Bubble persistence via Reanimated** – Instead of manual `Animated.ValueXY` bookkeeping, we can migrate to `react-native-gesture-handler` + `react-native-reanimated`. With shared values we can test orientation changes and persistence with fewer imperative calls, and we get built-in gesture velocity and snap points (useful for docking to any edge, not just the right).
- **Composable radial menu** – Extract the polar-coordinate math from `DialIcon.tsx` into a utility that takes `radius`, `angleOffset`, and `easing`. That makes it trivial to build alternate layouts (semi-circle, grid, context-sensitive arcs) without reimplementing the animation pipeline each time.
- **Schema-driven settings** – Rather than maintaining two parallel maps (`dialTools` and `floatingTools`), consider describing each tool once and annotating where it can render. The modal could render sections dynamically (`renderToolSection('Dial', tools.filter(t => t.supportsDial))`) and we’d never forget to update both branches.
- **Devtools launcher service** – Wrap `useAppHost` into a service that knows how to open common debug tools (logs, network, storage) even outside the floating menu. This allows CLI commands or deep links to launch tools without going through the UI shell.

## Documentation / Developer Experience
- Document that `InstalledApp.icon` receives `{ slot, size }` so downstream teams can render slot-specific glyphs. The examples in `example/App.tsx` only cover the static icon path; add a snippet in `docs/` for dynamic icons (e.g. showing error counts).
- Provide a migration guide for teams still using the legacy imperative dev tools. Highlight the new `component` + `launchMode` pathway and clarify how to bridge to promise-based handlers while we phase out `onPress`.
- Ship Storybook/Expo stories demonstrating each component (`FloatingTools`, `DialDevTools`, `DevToolsSettingsModal`) in isolation to catch visual regressions.

## Testing Gaps to Close
- Jest test ensuring the settings modal publishes updates over `settingsBus` and that `FloatingMenu` reacts immediately (mock `settingsBus.emit` + React Testing Library snapshot).
- Integration test verifying the AsyncStorage fallback path works when the module is absent (mock `global.__DEV__` or set Metro resolver to throw).
- Snapshot/visual regression coverage for the dial to ensure future style tweaks don’t break the neon theme.
- Unit test for `DraggableHeader` verifying the gesture clamp honors `minPosition` and `containerBounds`, especially after we relax it to support hide-on-drag.

## Open Questions
- Do we want the floating bubble to respect right-to-left layouts? Currently all coordinates assume LTR (hidden grabber on the right). If we flip to RTL the hide animation should mirror.
- Should `AppHost` expose a context menu so dev apps can close themselves or request focus? Some debug tools might want to dismiss neighbors (e.g. network inspector opening storage inspector).
- Are we comfortable storing settings under `@rn_better_dev_tools_settings` forever? If we rename the package users will lose preferences. Maybe namespace by package version to allow for schema migrations.

